/*
Copyright 2020 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/apis/etcd/etcdapi.proto

/*
Package etcd is a generated protocol buffer package.

It is generated from these files:
	pkg/apis/etcd/etcdapi.proto

It has these top-level messages:
	ClusterSpec
	Command
	RestoreBackupCommand
	CreateNewClusterCommand
	GetInfoRequest
	GetInfoResponse
	SetInfoRequest
	SetInfoResponse
	UpdateEndpointsRequest
	MemberMap
	MemberMapInfo
	UpdateEndpointsResponse
	BackupInfo
	CommonRequestHeader
	DoBackupRequest
	DoBackupResponse
	DoRestoreRequest
	DoRestoreResponse
	StopEtcdRequest
	StopEtcdResponse
	JoinClusterRequest
	JoinClusterResponse
	ReconfigureRequest
	ReconfigureResponse
	EtcdCluster
	EtcdNode
	EtcdState
*/
package etcd

import (
	fmt "fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Phase int32

const (
	Phase_PHASE_UNKNOWN         Phase = 0
	Phase_PHASE_PREPARE         Phase = 1
	Phase_PHASE_INITIAL_CLUSTER Phase = 2
	Phase_PHASE_JOIN_EXISTING   Phase = 3
	// Cancel a previous prepare (it times out eventually)
	Phase_PHASE_CANCEL_PREPARE Phase = 4
)

var Phase_name = map[int32]string{
	0: "PHASE_UNKNOWN",
	1: "PHASE_PREPARE",
	2: "PHASE_INITIAL_CLUSTER",
	3: "PHASE_JOIN_EXISTING",
	4: "PHASE_CANCEL_PREPARE",
}
var Phase_value = map[string]int32{
	"PHASE_UNKNOWN":         0,
	"PHASE_PREPARE":         1,
	"PHASE_INITIAL_CLUSTER": 2,
	"PHASE_JOIN_EXISTING":   3,
	"PHASE_CANCEL_PREPARE":  4,
}

func (x Phase) String() string {
	return proto.EnumName(Phase_name, int32(x))
}
func (Phase) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ClusterSpec struct {
	MemberCount int32  `protobuf:"varint,1,opt,name=member_count,json=memberCount" json:"member_count,omitempty"`
	EtcdVersion string `protobuf:"bytes,2,opt,name=etcd_version,json=etcdVersion" json:"etcd_version,omitempty"`
}

func (m *ClusterSpec) Reset()                    { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string            { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()               {}
func (*ClusterSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ClusterSpec) GetMemberCount() int32 {
	if m != nil {
		return m.MemberCount
	}
	return 0
}

func (m *ClusterSpec) GetEtcdVersion() string {
	if m != nil {
		return m.EtcdVersion
	}
	return ""
}

type Command struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// If restore backup is set, this indicates a request to restore the specified backup
	// This is not normally safe (potential for data loss if the backup is out of date),
	// but either the administrator can set this in a DR scenario,
	// or we set it ourselves immediately after having performed a quarantined backup
	RestoreBackup *RestoreBackupCommand `protobuf:"bytes,10,opt,name=restore_backup,json=restoreBackup" json:"restore_backup,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Command) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Command) GetRestoreBackup() *RestoreBackupCommand {
	if m != nil {
		return m.RestoreBackup
	}
	return nil
}

type RestoreBackupCommand struct {
	// The new cluster spec we should restore into
	ClusterSpec *ClusterSpec `protobuf:"bytes,1,opt,name=cluster_spec,json=clusterSpec" json:"cluster_spec,omitempty"`
	Backup      string       `protobuf:"bytes,3,opt,name=backup" json:"backup,omitempty"`
}

func (m *RestoreBackupCommand) Reset()                    { *m = RestoreBackupCommand{} }
func (m *RestoreBackupCommand) String() string            { return proto.CompactTextString(m) }
func (*RestoreBackupCommand) ProtoMessage()               {}
func (*RestoreBackupCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RestoreBackupCommand) GetClusterSpec() *ClusterSpec {
	if m != nil {
		return m.ClusterSpec
	}
	return nil
}

func (m *RestoreBackupCommand) GetBackup() string {
	if m != nil {
		return m.Backup
	}
	return ""
}

type CreateNewClusterCommand struct {
	ClusterSpec *ClusterSpec `protobuf:"bytes,1,opt,name=cluster_spec,json=clusterSpec" json:"cluster_spec,omitempty"`
}

func (m *CreateNewClusterCommand) Reset()                    { *m = CreateNewClusterCommand{} }
func (m *CreateNewClusterCommand) String() string            { return proto.CompactTextString(m) }
func (*CreateNewClusterCommand) ProtoMessage()               {}
func (*CreateNewClusterCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateNewClusterCommand) GetClusterSpec() *ClusterSpec {
	if m != nil {
		return m.ClusterSpec
	}
	return nil
}

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type GetInfoResponse struct {
	ClusterName       string     `protobuf:"bytes,2,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	NodeConfiguration *EtcdNode  `protobuf:"bytes,5,opt,name=node_configuration,json=nodeConfiguration" json:"node_configuration,omitempty"`
	EtcdState         *EtcdState `protobuf:"bytes,6,opt,name=etcd_state,json=etcdState" json:"etcd_state,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetInfoResponse) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *GetInfoResponse) GetNodeConfiguration() *EtcdNode {
	if m != nil {
		return m.NodeConfiguration
	}
	return nil
}

func (m *GetInfoResponse) GetEtcdState() *EtcdState {
	if m != nil {
		return m.EtcdState
	}
	return nil
}

type SetInfoRequest struct {
	ClusterName       string     `protobuf:"bytes,1,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	NodeConfiguration *EtcdNode  `protobuf:"bytes,2,opt,name=node_configuration,json=nodeConfiguration" json:"node_configuration,omitempty"`
	EtcdState         *EtcdState `protobuf:"bytes,3,opt,name=etcd_state,json=etcdState" json:"etcd_state,omitempty"`
}

func (m *SetInfoRequest) Reset()                    { *m = SetInfoRequest{} }
func (m *SetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*SetInfoRequest) ProtoMessage()               {}
func (*SetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SetInfoRequest) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *SetInfoRequest) GetNodeConfiguration() *EtcdNode {
	if m != nil {
		return m.NodeConfiguration
	}
	return nil
}

func (m *SetInfoRequest) GetEtcdState() *EtcdState {
	if m != nil {
		return m.EtcdState
	}
	return nil
}

type SetInfoResponse struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *SetInfoResponse) Reset()                    { *m = SetInfoResponse{} }
func (m *SetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*SetInfoResponse) ProtoMessage()               {}
func (*SetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SetInfoResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type UpdateEndpointsRequest struct {
	// Contains information about the current nodes
	// It can be used for nodes to update /etc/hosts
	MemberMap *MemberMap `protobuf:"bytes,1,opt,name=member_map,json=memberMap" json:"member_map,omitempty"`
}

func (m *UpdateEndpointsRequest) Reset()                    { *m = UpdateEndpointsRequest{} }
func (m *UpdateEndpointsRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateEndpointsRequest) ProtoMessage()               {}
func (*UpdateEndpointsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpdateEndpointsRequest) GetMemberMap() *MemberMap {
	if m != nil {
		return m.MemberMap
	}
	return nil
}

type MemberMap struct {
	Members []*MemberMapInfo `protobuf:"bytes,1,rep,name=members" json:"members,omitempty"`
}

func (m *MemberMap) Reset()                    { *m = MemberMap{} }
func (m *MemberMap) String() string            { return proto.CompactTextString(m) }
func (*MemberMap) ProtoMessage()               {}
func (*MemberMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *MemberMap) GetMembers() []*MemberMapInfo {
	if m != nil {
		return m.Members
	}
	return nil
}

type MemberMapInfo struct {
	Name      string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Dns       string   `protobuf:"bytes,2,opt,name=dns" json:"dns,omitempty"`
	Addresses []string `protobuf:"bytes,3,rep,name=addresses" json:"addresses,omitempty"`
}

func (m *MemberMapInfo) Reset()                    { *m = MemberMapInfo{} }
func (m *MemberMapInfo) String() string            { return proto.CompactTextString(m) }
func (*MemberMapInfo) ProtoMessage()               {}
func (*MemberMapInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MemberMapInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemberMapInfo) GetDns() string {
	if m != nil {
		return m.Dns
	}
	return ""
}

func (m *MemberMapInfo) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

type UpdateEndpointsResponse struct {
}

func (m *UpdateEndpointsResponse) Reset()                    { *m = UpdateEndpointsResponse{} }
func (m *UpdateEndpointsResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateEndpointsResponse) ProtoMessage()               {}
func (*UpdateEndpointsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type BackupInfo struct {
	EtcdVersion string       `protobuf:"bytes,1,opt,name=etcd_version,json=etcdVersion" json:"etcd_version,omitempty"`
	Timestamp   int64        `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	ClusterSpec *ClusterSpec `protobuf:"bytes,3,opt,name=cluster_spec,json=clusterSpec" json:"cluster_spec,omitempty"`
}

func (m *BackupInfo) Reset()                    { *m = BackupInfo{} }
func (m *BackupInfo) String() string            { return proto.CompactTextString(m) }
func (*BackupInfo) ProtoMessage()               {}
func (*BackupInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *BackupInfo) GetEtcdVersion() string {
	if m != nil {
		return m.EtcdVersion
	}
	return ""
}

func (m *BackupInfo) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *BackupInfo) GetClusterSpec() *ClusterSpec {
	if m != nil {
		return m.ClusterSpec
	}
	return nil
}

type CommonRequestHeader struct {
	LeadershipToken string `protobuf:"bytes,1,opt,name=leadership_token,json=leadershipToken" json:"leadership_token,omitempty"`
	ClusterName     string `protobuf:"bytes,2,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
}

func (m *CommonRequestHeader) Reset()                    { *m = CommonRequestHeader{} }
func (m *CommonRequestHeader) String() string            { return proto.CompactTextString(m) }
func (*CommonRequestHeader) ProtoMessage()               {}
func (*CommonRequestHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CommonRequestHeader) GetLeadershipToken() string {
	if m != nil {
		return m.LeadershipToken
	}
	return ""
}

func (m *CommonRequestHeader) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

type DoBackupRequest struct {
	Header  *CommonRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Storage string               `protobuf:"bytes,2,opt,name=storage" json:"storage,omitempty"`
	// If allow_offline_backup is true, backup will be permitted even if etcd is not running on the node
	AllowOfflineBackup bool        `protobuf:"varint,4,opt,name=allow_offline_backup,json=allowOfflineBackup" json:"allow_offline_backup,omitempty"`
	Info               *BackupInfo `protobuf:"bytes,10,opt,name=info" json:"info,omitempty"`
}

func (m *DoBackupRequest) Reset()                    { *m = DoBackupRequest{} }
func (m *DoBackupRequest) String() string            { return proto.CompactTextString(m) }
func (*DoBackupRequest) ProtoMessage()               {}
func (*DoBackupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DoBackupRequest) GetHeader() *CommonRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DoBackupRequest) GetStorage() string {
	if m != nil {
		return m.Storage
	}
	return ""
}

func (m *DoBackupRequest) GetAllowOfflineBackup() bool {
	if m != nil {
		return m.AllowOfflineBackup
	}
	return false
}

func (m *DoBackupRequest) GetInfo() *BackupInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type DoBackupResponse struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DoBackupResponse) Reset()                    { *m = DoBackupResponse{} }
func (m *DoBackupResponse) String() string            { return proto.CompactTextString(m) }
func (*DoBackupResponse) ProtoMessage()               {}
func (*DoBackupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *DoBackupResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DoRestoreRequest struct {
	Header     *CommonRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Storage    string               `protobuf:"bytes,2,opt,name=storage" json:"storage,omitempty"`
	BackupName string               `protobuf:"bytes,4,opt,name=backup_name,json=backupName" json:"backup_name,omitempty"`
}

func (m *DoRestoreRequest) Reset()                    { *m = DoRestoreRequest{} }
func (m *DoRestoreRequest) String() string            { return proto.CompactTextString(m) }
func (*DoRestoreRequest) ProtoMessage()               {}
func (*DoRestoreRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *DoRestoreRequest) GetHeader() *CommonRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DoRestoreRequest) GetStorage() string {
	if m != nil {
		return m.Storage
	}
	return ""
}

func (m *DoRestoreRequest) GetBackupName() string {
	if m != nil {
		return m.BackupName
	}
	return ""
}

type DoRestoreResponse struct {
}

func (m *DoRestoreResponse) Reset()                    { *m = DoRestoreResponse{} }
func (m *DoRestoreResponse) String() string            { return proto.CompactTextString(m) }
func (*DoRestoreResponse) ProtoMessage()               {}
func (*DoRestoreResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type StopEtcdRequest struct {
	Header *CommonRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
}

func (m *StopEtcdRequest) Reset()                    { *m = StopEtcdRequest{} }
func (m *StopEtcdRequest) String() string            { return proto.CompactTextString(m) }
func (*StopEtcdRequest) ProtoMessage()               {}
func (*StopEtcdRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *StopEtcdRequest) GetHeader() *CommonRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type StopEtcdResponse struct {
}

func (m *StopEtcdResponse) Reset()                    { *m = StopEtcdResponse{} }
func (m *StopEtcdResponse) String() string            { return proto.CompactTextString(m) }
func (*StopEtcdResponse) ProtoMessage()               {}
func (*StopEtcdResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type JoinClusterRequest struct {
	Header       *CommonRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Phase        Phase                `protobuf:"varint,2,opt,name=phase,enum=etcd.Phase" json:"phase,omitempty"`
	ClusterToken string               `protobuf:"bytes,4,opt,name=cluster_token,json=clusterToken" json:"cluster_token,omitempty"`
	Nodes        []*EtcdNode          `protobuf:"bytes,5,rep,name=nodes" json:"nodes,omitempty"`
	AddNode      *EtcdNode            `protobuf:"bytes,6,opt,name=add_node,json=addNode" json:"add_node,omitempty"`
	EtcdVersion  string               `protobuf:"bytes,7,opt,name=etcd_version,json=etcdVersion" json:"etcd_version,omitempty"`
}

func (m *JoinClusterRequest) Reset()                    { *m = JoinClusterRequest{} }
func (m *JoinClusterRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinClusterRequest) ProtoMessage()               {}
func (*JoinClusterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *JoinClusterRequest) GetHeader() *CommonRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *JoinClusterRequest) GetPhase() Phase {
	if m != nil {
		return m.Phase
	}
	return Phase_PHASE_UNKNOWN
}

func (m *JoinClusterRequest) GetClusterToken() string {
	if m != nil {
		return m.ClusterToken
	}
	return ""
}

func (m *JoinClusterRequest) GetNodes() []*EtcdNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *JoinClusterRequest) GetAddNode() *EtcdNode {
	if m != nil {
		return m.AddNode
	}
	return nil
}

func (m *JoinClusterRequest) GetEtcdVersion() string {
	if m != nil {
		return m.EtcdVersion
	}
	return ""
}

type JoinClusterResponse struct {
}

func (m *JoinClusterResponse) Reset()                    { *m = JoinClusterResponse{} }
func (m *JoinClusterResponse) String() string            { return proto.CompactTextString(m) }
func (*JoinClusterResponse) ProtoMessage()               {}
func (*JoinClusterResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

type ReconfigureRequest struct {
	Header         *CommonRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	SetEtcdVersion string               `protobuf:"bytes,10,opt,name=set_etcd_version,json=setEtcdVersion" json:"set_etcd_version,omitempty"`
	// Note that because this is bool this must always be specified
	Quarantined bool `protobuf:"varint,11,opt,name=quarantined" json:"quarantined,omitempty"`
	// Note that because this is bool we need two fields
	EnableTls bool `protobuf:"varint,12,opt,name=enable_tls,json=enableTls" json:"enable_tls,omitempty"`
}

func (m *ReconfigureRequest) Reset()                    { *m = ReconfigureRequest{} }
func (m *ReconfigureRequest) String() string            { return proto.CompactTextString(m) }
func (*ReconfigureRequest) ProtoMessage()               {}
func (*ReconfigureRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ReconfigureRequest) GetHeader() *CommonRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReconfigureRequest) GetSetEtcdVersion() string {
	if m != nil {
		return m.SetEtcdVersion
	}
	return ""
}

func (m *ReconfigureRequest) GetQuarantined() bool {
	if m != nil {
		return m.Quarantined
	}
	return false
}

func (m *ReconfigureRequest) GetEnableTls() bool {
	if m != nil {
		return m.EnableTls
	}
	return false
}

type ReconfigureResponse struct {
}

func (m *ReconfigureResponse) Reset()                    { *m = ReconfigureResponse{} }
func (m *ReconfigureResponse) String() string            { return proto.CompactTextString(m) }
func (*ReconfigureResponse) ProtoMessage()               {}
func (*ReconfigureResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

type EtcdCluster struct {
	DesiredClusterSize int32 `protobuf:"varint,1,opt,name=desired_cluster_size,json=desiredClusterSize" json:"desired_cluster_size,omitempty"`
	//    int32 peer_port = 2;
	//    int32 client_port = 3;
	//    string cluster_name = 4;
	ClusterToken string `protobuf:"bytes,5,opt,name=cluster_token,json=clusterToken" json:"cluster_token,omitempty"`
	// string my_id = 6;
	Nodes []*EtcdNode `protobuf:"bytes,7,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *EtcdCluster) Reset()                    { *m = EtcdCluster{} }
func (m *EtcdCluster) String() string            { return proto.CompactTextString(m) }
func (*EtcdCluster) ProtoMessage()               {}
func (*EtcdCluster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *EtcdCluster) GetDesiredClusterSize() int32 {
	if m != nil {
		return m.DesiredClusterSize
	}
	return 0
}

func (m *EtcdCluster) GetClusterToken() string {
	if m != nil {
		return m.ClusterToken
	}
	return ""
}

func (m *EtcdCluster) GetNodes() []*EtcdNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type EtcdNode struct {
	Name                  string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	PeerUrls              []string `protobuf:"bytes,2,rep,name=peer_urls,json=peerUrls" json:"peer_urls,omitempty"`
	ClientUrls            []string `protobuf:"bytes,3,rep,name=client_urls,json=clientUrls" json:"client_urls,omitempty"`
	QuarantinedClientUrls []string `protobuf:"bytes,4,rep,name=quarantined_client_urls,json=quarantinedClientUrls" json:"quarantined_client_urls,omitempty"`
	TlsEnabled            bool     `protobuf:"varint,5,opt,name=tls_enabled,json=tlsEnabled" json:"tls_enabled,omitempty"`
}

func (m *EtcdNode) Reset()                    { *m = EtcdNode{} }
func (m *EtcdNode) String() string            { return proto.CompactTextString(m) }
func (*EtcdNode) ProtoMessage()               {}
func (*EtcdNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *EtcdNode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EtcdNode) GetPeerUrls() []string {
	if m != nil {
		return m.PeerUrls
	}
	return nil
}

func (m *EtcdNode) GetClientUrls() []string {
	if m != nil {
		return m.ClientUrls
	}
	return nil
}

func (m *EtcdNode) GetQuarantinedClientUrls() []string {
	if m != nil {
		return m.QuarantinedClientUrls
	}
	return nil
}

func (m *EtcdNode) GetTlsEnabled() bool {
	if m != nil {
		return m.TlsEnabled
	}
	return false
}

type EtcdState struct {
	NewCluster  bool         `protobuf:"varint,1,opt,name=new_cluster,json=newCluster" json:"new_cluster,omitempty"`
	Cluster     *EtcdCluster `protobuf:"bytes,2,opt,name=cluster" json:"cluster,omitempty"`
	EtcdVersion string       `protobuf:"bytes,3,opt,name=etcd_version,json=etcdVersion" json:"etcd_version,omitempty"`
	Quarantined bool         `protobuf:"varint,4,opt,name=quarantined" json:"quarantined,omitempty"`
}

func (m *EtcdState) Reset()                    { *m = EtcdState{} }
func (m *EtcdState) String() string            { return proto.CompactTextString(m) }
func (*EtcdState) ProtoMessage()               {}
func (*EtcdState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *EtcdState) GetNewCluster() bool {
	if m != nil {
		return m.NewCluster
	}
	return false
}

func (m *EtcdState) GetCluster() *EtcdCluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *EtcdState) GetEtcdVersion() string {
	if m != nil {
		return m.EtcdVersion
	}
	return ""
}

func (m *EtcdState) GetQuarantined() bool {
	if m != nil {
		return m.Quarantined
	}
	return false
}

func init() {
	proto.RegisterType((*ClusterSpec)(nil), "etcd.ClusterSpec")
	proto.RegisterType((*Command)(nil), "etcd.Command")
	proto.RegisterType((*RestoreBackupCommand)(nil), "etcd.RestoreBackupCommand")
	proto.RegisterType((*CreateNewClusterCommand)(nil), "etcd.CreateNewClusterCommand")
	proto.RegisterType((*GetInfoRequest)(nil), "etcd.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "etcd.GetInfoResponse")
	proto.RegisterType((*SetInfoRequest)(nil), "etcd.SetInfoRequest")
	proto.RegisterType((*SetInfoResponse)(nil), "etcd.SetInfoResponse")
	proto.RegisterType((*UpdateEndpointsRequest)(nil), "etcd.UpdateEndpointsRequest")
	proto.RegisterType((*MemberMap)(nil), "etcd.MemberMap")
	proto.RegisterType((*MemberMapInfo)(nil), "etcd.MemberMapInfo")
	proto.RegisterType((*UpdateEndpointsResponse)(nil), "etcd.UpdateEndpointsResponse")
	proto.RegisterType((*BackupInfo)(nil), "etcd.BackupInfo")
	proto.RegisterType((*CommonRequestHeader)(nil), "etcd.CommonRequestHeader")
	proto.RegisterType((*DoBackupRequest)(nil), "etcd.DoBackupRequest")
	proto.RegisterType((*DoBackupResponse)(nil), "etcd.DoBackupResponse")
	proto.RegisterType((*DoRestoreRequest)(nil), "etcd.DoRestoreRequest")
	proto.RegisterType((*DoRestoreResponse)(nil), "etcd.DoRestoreResponse")
	proto.RegisterType((*StopEtcdRequest)(nil), "etcd.StopEtcdRequest")
	proto.RegisterType((*StopEtcdResponse)(nil), "etcd.StopEtcdResponse")
	proto.RegisterType((*JoinClusterRequest)(nil), "etcd.JoinClusterRequest")
	proto.RegisterType((*JoinClusterResponse)(nil), "etcd.JoinClusterResponse")
	proto.RegisterType((*ReconfigureRequest)(nil), "etcd.ReconfigureRequest")
	proto.RegisterType((*ReconfigureResponse)(nil), "etcd.ReconfigureResponse")
	proto.RegisterType((*EtcdCluster)(nil), "etcd.EtcdCluster")
	proto.RegisterType((*EtcdNode)(nil), "etcd.EtcdNode")
	proto.RegisterType((*EtcdState)(nil), "etcd.EtcdState")
	proto.RegisterEnum("etcd.Phase", Phase_name, Phase_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EtcdManagerService service

type EtcdManagerServiceClient interface {
	// GetInfo gets info about the node
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// SetInfo sets info about the node, when the state becomes stale
	SetInfo(ctx context.Context, in *SetInfoRequest, opts ...grpc.CallOption) (*SetInfoResponse, error)
	// UpdateEndpoints is sent to peers so they can update their inter-cluster routing
	UpdateEndpoints(ctx context.Context, in *UpdateEndpointsRequest, opts ...grpc.CallOption) (*UpdateEndpointsResponse, error)
	// JoinCluster requests that the node join an existing cluster
	JoinCluster(ctx context.Context, in *JoinClusterRequest, opts ...grpc.CallOption) (*JoinClusterResponse, error)
	// Reconfigure changes the configuration of an existing node, primarily for a version upgrade/downgrade
	Reconfigure(ctx context.Context, in *ReconfigureRequest, opts ...grpc.CallOption) (*ReconfigureResponse, error)
	// DoBackup requests that the node backup etcd
	DoBackup(ctx context.Context, in *DoBackupRequest, opts ...grpc.CallOption) (*DoBackupResponse, error)
	// DoRestore requests that the node restores an etcd backup
	DoRestore(ctx context.Context, in *DoRestoreRequest, opts ...grpc.CallOption) (*DoRestoreResponse, error)
	// StopEtcd requests that the node no longer run etcd.
	// Typically the node will already have been removed from the etcd cluster.
	StopEtcd(ctx context.Context, in *StopEtcdRequest, opts ...grpc.CallOption) (*StopEtcdResponse, error)
}

type etcdManagerServiceClient struct {
	cc *grpc.ClientConn
}

func NewEtcdManagerServiceClient(cc *grpc.ClientConn) EtcdManagerServiceClient {
	return &etcdManagerServiceClient{cc}
}

func (c *etcdManagerServiceClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) SetInfo(ctx context.Context, in *SetInfoRequest, opts ...grpc.CallOption) (*SetInfoResponse, error) {
	out := new(SetInfoResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/SetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) UpdateEndpoints(ctx context.Context, in *UpdateEndpointsRequest, opts ...grpc.CallOption) (*UpdateEndpointsResponse, error) {
	out := new(UpdateEndpointsResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/UpdateEndpoints", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) JoinCluster(ctx context.Context, in *JoinClusterRequest, opts ...grpc.CallOption) (*JoinClusterResponse, error) {
	out := new(JoinClusterResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/JoinCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) Reconfigure(ctx context.Context, in *ReconfigureRequest, opts ...grpc.CallOption) (*ReconfigureResponse, error) {
	out := new(ReconfigureResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/Reconfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) DoBackup(ctx context.Context, in *DoBackupRequest, opts ...grpc.CallOption) (*DoBackupResponse, error) {
	out := new(DoBackupResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/DoBackup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) DoRestore(ctx context.Context, in *DoRestoreRequest, opts ...grpc.CallOption) (*DoRestoreResponse, error) {
	out := new(DoRestoreResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/DoRestore", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *etcdManagerServiceClient) StopEtcd(ctx context.Context, in *StopEtcdRequest, opts ...grpc.CallOption) (*StopEtcdResponse, error) {
	out := new(StopEtcdResponse)
	err := grpc.Invoke(ctx, "/etcd.EtcdManagerService/StopEtcd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EtcdManagerService service

type EtcdManagerServiceServer interface {
	// GetInfo gets info about the node
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// SetInfo sets info about the node, when the state becomes stale
	SetInfo(context.Context, *SetInfoRequest) (*SetInfoResponse, error)
	// UpdateEndpoints is sent to peers so they can update their inter-cluster routing
	UpdateEndpoints(context.Context, *UpdateEndpointsRequest) (*UpdateEndpointsResponse, error)
	// JoinCluster requests that the node join an existing cluster
	JoinCluster(context.Context, *JoinClusterRequest) (*JoinClusterResponse, error)
	// Reconfigure changes the configuration of an existing node, primarily for a version upgrade/downgrade
	Reconfigure(context.Context, *ReconfigureRequest) (*ReconfigureResponse, error)
	// DoBackup requests that the node backup etcd
	DoBackup(context.Context, *DoBackupRequest) (*DoBackupResponse, error)
	// DoRestore requests that the node restores an etcd backup
	DoRestore(context.Context, *DoRestoreRequest) (*DoRestoreResponse, error)
	// StopEtcd requests that the node no longer run etcd.
	// Typically the node will already have been removed from the etcd cluster.
	StopEtcd(context.Context, *StopEtcdRequest) (*StopEtcdResponse, error)
}

func RegisterEtcdManagerServiceServer(s *grpc.Server, srv EtcdManagerServiceServer) {
	s.RegisterService(&_EtcdManagerService_serviceDesc, srv)
}

func _EtcdManagerService_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_SetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).SetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/SetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).SetInfo(ctx, req.(*SetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_UpdateEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEndpointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).UpdateEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/UpdateEndpoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).UpdateEndpoints(ctx, req.(*UpdateEndpointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_JoinCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).JoinCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/JoinCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).JoinCluster(ctx, req.(*JoinClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_Reconfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).Reconfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/Reconfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).Reconfigure(ctx, req.(*ReconfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_DoBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).DoBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/DoBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).DoBackup(ctx, req.(*DoBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_DoRestore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoRestoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).DoRestore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/DoRestore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).DoRestore(ctx, req.(*DoRestoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EtcdManagerService_StopEtcd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopEtcdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EtcdManagerServiceServer).StopEtcd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/etcd.EtcdManagerService/StopEtcd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EtcdManagerServiceServer).StopEtcd(ctx, req.(*StopEtcdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EtcdManagerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "etcd.EtcdManagerService",
	HandlerType: (*EtcdManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _EtcdManagerService_GetInfo_Handler,
		},
		{
			MethodName: "SetInfo",
			Handler:    _EtcdManagerService_SetInfo_Handler,
		},
		{
			MethodName: "UpdateEndpoints",
			Handler:    _EtcdManagerService_UpdateEndpoints_Handler,
		},
		{
			MethodName: "JoinCluster",
			Handler:    _EtcdManagerService_JoinCluster_Handler,
		},
		{
			MethodName: "Reconfigure",
			Handler:    _EtcdManagerService_Reconfigure_Handler,
		},
		{
			MethodName: "DoBackup",
			Handler:    _EtcdManagerService_DoBackup_Handler,
		},
		{
			MethodName: "DoRestore",
			Handler:    _EtcdManagerService_DoRestore_Handler,
		},
		{
			MethodName: "StopEtcd",
			Handler:    _EtcdManagerService_StopEtcd_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/apis/etcd/etcdapi.proto",
}

func init() { proto.RegisterFile("pkg/apis/etcd/etcdapi.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1257 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x5d, 0x6f, 0xdb, 0xd4,
	0x1b, 0xff, 0x3b, 0x2f, 0x4d, 0xf2, 0x78, 0x4d, 0xd2, 0xd3, 0x76, 0x4d, 0xb3, 0x4d, 0xeb, 0xfc,
	0x9f, 0x50, 0xc6, 0xb4, 0x0c, 0x0a, 0x9a, 0x04, 0x82, 0x8b, 0x2e, 0x8b, 0xb6, 0x8c, 0x35, 0xad,
	0xec, 0x16, 0x10, 0x37, 0xd6, 0xa9, 0x7d, 0xda, 0x9a, 0x3a, 0xb6, 0xe7, 0x73, 0xb2, 0x4a, 0xe3,
	0x06, 0x89, 0x3b, 0xae, 0xf8, 0x04, 0x5c, 0xc0, 0x37, 0x40, 0x82, 0xcf, 0x87, 0xce, 0x5b, 0xe2,
	0xd8, 0x61, 0x54, 0xab, 0xb8, 0x89, 0x8e, 0x7f, 0xcf, 0x73, 0x9e, 0xf7, 0x97, 0x13, 0xb8, 0x95,
	0x5c, 0x9c, 0x3d, 0xc6, 0x49, 0x40, 0x1f, 0x13, 0xe6, 0xf9, 0xe2, 0x07, 0x27, 0x41, 0x3f, 0x49,
	0x63, 0x16, 0xa3, 0x0a, 0xff, 0xb4, 0x1c, 0x30, 0x07, 0xe1, 0x94, 0x32, 0x92, 0x3a, 0x09, 0xf1,
	0xd0, 0x3d, 0xb8, 0x31, 0x21, 0x93, 0x13, 0x92, 0xba, 0x5e, 0x3c, 0x8d, 0x58, 0xc7, 0xd8, 0x31,
	0x7a, 0x55, 0xdb, 0x94, 0xd8, 0x80, 0x43, 0x9c, 0x85, 0xdf, 0x74, 0xdf, 0x90, 0x94, 0x06, 0x71,
	0xd4, 0x29, 0xed, 0x18, 0xbd, 0x86, 0x6d, 0x72, 0xec, 0x6b, 0x09, 0x59, 0xdf, 0x43, 0x6d, 0x10,
	0x4f, 0x26, 0x38, 0xf2, 0xd1, 0x6d, 0x68, 0xb0, 0x60, 0x42, 0x28, 0xc3, 0x93, 0x44, 0x48, 0x2b,
	0xdb, 0x73, 0x00, 0xed, 0x41, 0x33, 0x25, 0x94, 0xc5, 0x29, 0x71, 0x4f, 0xb0, 0x77, 0x31, 0x4d,
	0x3a, 0xb0, 0x63, 0xf4, 0xcc, 0xdd, 0x6e, 0x9f, 0x8b, 0xeb, 0xdb, 0x92, 0xf6, 0x54, 0x90, 0x94,
	0x44, 0x7b, 0x35, 0xcd, 0xa2, 0x96, 0x0f, 0x1b, 0xcb, 0xd8, 0xd0, 0xa7, 0x70, 0xc3, 0x93, 0x8e,
	0xb9, 0x34, 0x21, 0x9e, 0xd0, 0x6d, 0xee, 0xae, 0x49, 0xc1, 0x19, 0x97, 0x6d, 0xd3, 0xcb, 0xf8,
	0x7f, 0x13, 0x56, 0x94, 0x21, 0x65, 0xe1, 0x96, 0xfa, 0xb2, 0x0e, 0x60, 0x6b, 0x90, 0x12, 0xcc,
	0xc8, 0x98, 0x5c, 0xaa, 0xcb, 0xd7, 0x52, 0x64, 0xb5, 0xa1, 0xf9, 0x9c, 0xb0, 0x51, 0x74, 0x1a,
	0xdb, 0xe4, 0xf5, 0x94, 0x50, 0x66, 0xfd, 0x6e, 0x40, 0x6b, 0x06, 0xd1, 0x24, 0x8e, 0x28, 0xe1,
	0xb1, 0xd6, 0xb2, 0x23, 0x3c, 0x21, 0x3a, 0xd6, 0x0a, 0x1b, 0xe3, 0x09, 0x41, 0x5f, 0x02, 0x8a,
	0x62, 0x9f, 0xb8, 0x5e, 0x1c, 0x9d, 0x06, 0x67, 0xd3, 0x14, 0x33, 0x9e, 0x94, 0xaa, 0x30, 0xa2,
	0x29, 0x8d, 0x18, 0x32, 0xcf, 0x1f, 0xc7, 0x3e, 0xb1, 0xd7, 0x38, 0xe7, 0x20, 0xcb, 0x88, 0xfa,
	0x00, 0x22, 0x9b, 0x94, 0x61, 0x46, 0x3a, 0x2b, 0xe2, 0x5a, 0x6b, 0x7e, 0xcd, 0xe1, 0xb0, 0xdd,
	0x20, 0xfa, 0x68, 0xfd, 0x66, 0x40, 0xd3, 0x59, 0x30, 0xbc, 0x60, 0xa4, 0x71, 0x55, 0x23, 0x4b,
	0xef, 0x67, 0x64, 0xf9, 0x5f, 0x8d, 0x7c, 0x08, 0x2d, 0x27, 0x17, 0xc9, 0x0e, 0xd4, 0xe8, 0xd4,
	0xf3, 0x08, 0xa5, 0xc2, 0xbe, 0xba, 0xad, 0x3f, 0xad, 0x17, 0x70, 0xf3, 0x38, 0xf1, 0x31, 0x23,
	0xc3, 0xc8, 0x4f, 0xe2, 0x20, 0x62, 0x54, 0x3b, 0xd6, 0x07, 0x50, 0xcd, 0x30, 0xc1, 0x89, 0xca,
	0xab, 0x52, 0xbb, 0x2f, 0xf0, 0x7d, 0x9c, 0xd8, 0x8d, 0x89, 0x3e, 0x5a, 0x9f, 0x43, 0x63, 0x86,
	0xa3, 0x47, 0x50, 0x93, 0x14, 0xae, 0xb0, 0xdc, 0x33, 0x77, 0xd7, 0x73, 0x37, 0x85, 0x79, 0x9a,
	0xc7, 0x72, 0x60, 0x75, 0x81, 0x82, 0x10, 0x54, 0x32, 0xd1, 0x14, 0x67, 0xd4, 0x86, 0xb2, 0x1f,
	0x51, 0x55, 0x05, 0xfc, 0xc8, 0xdb, 0x0b, 0xfb, 0x7e, 0x4a, 0x28, 0x25, 0xb4, 0x53, 0xde, 0x29,
	0xf7, 0x1a, 0xf6, 0x1c, 0xb0, 0xb6, 0x61, 0xab, 0xe0, 0x9a, 0x8c, 0x87, 0xf5, 0x93, 0x01, 0x20,
	0x1b, 0x46, 0x68, 0xcb, 0x37, 0xb5, 0x51, 0x68, 0xea, 0xc5, 0x4e, 0x2e, 0xe5, 0x3b, 0x39, 0xdf,
	0x05, 0xe5, 0x2b, 0x75, 0x81, 0x07, 0xeb, 0xbc, 0x8d, 0xe2, 0x48, 0x85, 0xfc, 0x05, 0xc1, 0x3e,
	0x49, 0xd1, 0x03, 0x68, 0x87, 0xe2, 0x44, 0xcf, 0x83, 0xc4, 0x65, 0xf1, 0x05, 0xd1, 0x16, 0xb5,
	0xe6, 0xf8, 0x11, 0x87, 0xaf, 0xd0, 0x21, 0xd6, 0x5f, 0x06, 0xb4, 0x9e, 0xc5, 0xd2, 0x59, 0x9d,
	0xda, 0x8f, 0x61, 0xe5, 0x5c, 0x48, 0x52, 0x69, 0xdd, 0x56, 0x86, 0x16, 0x8d, 0xb1, 0x15, 0xa3,
	0xa8, 0x20, 0x16, 0xa7, 0xf8, 0x4c, 0x2b, 0xd1, 0x9f, 0xe8, 0x23, 0xd8, 0xc0, 0x61, 0x18, 0x5f,
	0xba, 0xf1, 0xe9, 0x69, 0x18, 0x44, 0xb3, 0x59, 0x56, 0x11, 0x85, 0x86, 0x04, 0xed, 0x40, 0x92,
	0xa4, 0x15, 0xe8, 0x3e, 0x54, 0x82, 0xe8, 0x34, 0x56, 0xd3, 0xae, 0x2d, 0x95, 0xcf, 0xd3, 0x61,
	0x0b, 0xaa, 0xf5, 0x01, 0xb4, 0xe7, 0x76, 0xab, 0x3a, 0x5e, 0x52, 0x16, 0xd6, 0x8f, 0x06, 0x67,
	0x54, 0x53, 0xf0, 0x3f, 0xf1, 0xf0, 0x2e, 0x98, 0xd2, 0x27, 0x19, 0xe4, 0x8a, 0xa0, 0x82, 0x84,
	0x44, 0x8c, 0xd7, 0x61, 0x2d, 0x63, 0x81, 0xaa, 0xb1, 0x67, 0xd0, 0x72, 0x58, 0x9c, 0xf0, 0x16,
	0x7d, 0x7f, 0xab, 0x2c, 0x04, 0xed, 0xb9, 0x14, 0x5d, 0xbd, 0x25, 0x40, 0x2f, 0xe3, 0x20, 0x52,
	0x85, 0x75, 0x0d, 0x9f, 0xef, 0x41, 0x35, 0x39, 0xc7, 0x54, 0x7a, 0xdc, 0xdc, 0x35, 0xe5, 0x8d,
	0x43, 0x0e, 0xd9, 0x92, 0x82, 0xfe, 0x0f, 0xab, 0xba, 0xc4, 0x64, 0x29, 0x4a, 0xf7, 0x75, 0xdd,
	0xc9, 0x3a, 0xbc, 0x0f, 0x55, 0x3e, 0xb7, 0x68, 0xa7, 0x2a, 0x9a, 0x3d, 0x3f, 0xd4, 0x24, 0x11,
	0x3d, 0x80, 0x3a, 0xf6, 0x7d, 0x97, 0x7f, 0xa8, 0x59, 0x9b, 0x67, 0xac, 0x61, 0x5f, 0x1c, 0x0a,
	0x1d, 0x59, 0x2b, 0xae, 0xd9, 0x4d, 0x58, 0x5f, 0x08, 0x82, 0x0a, 0xce, 0x1f, 0x06, 0x20, 0x9b,
	0xe8, 0x51, 0x7b, 0x9d, 0x82, 0xe8, 0x41, 0x9b, 0x12, 0xe6, 0x2e, 0xd8, 0x01, 0xc2, 0x8e, 0x26,
	0x25, 0x6c, 0x98, 0x19, 0x0e, 0x3b, 0x60, 0xbe, 0x9e, 0xe2, 0x14, 0x47, 0x2c, 0x88, 0x88, 0xdf,
	0x31, 0x45, 0xe5, 0x67, 0x21, 0x74, 0x07, 0x80, 0x44, 0xf8, 0x24, 0x24, 0x2e, 0x0b, 0x69, 0xe7,
	0x86, 0x60, 0x68, 0x48, 0xe4, 0x28, 0xa4, 0xdc, 0x97, 0x05, 0x9b, 0x95, 0x2f, 0x3f, 0x1b, 0x60,
	0x72, 0x3d, 0xca, 0x47, 0xde, 0x6a, 0x3e, 0xa1, 0x41, 0x4a, 0x7c, 0x77, 0x36, 0x6e, 0x82, 0xb7,
	0x44, 0xbd, 0x53, 0x90, 0xa2, 0xe9, 0x79, 0x13, 0xbc, 0x5d, 0x92, 0xbd, 0xea, 0xbb, 0xb2, 0x57,
	0x7b, 0x47, 0xf6, 0xac, 0x3f, 0x0d, 0xa8, 0x6b, 0x6c, 0xe9, 0x7c, 0xbe, 0x05, 0x8d, 0x84, 0x90,
	0xd4, 0x9d, 0xa6, 0x21, 0x9f, 0xd2, 0x7c, 0x1a, 0xd7, 0x39, 0x70, 0x9c, 0x86, 0x94, 0xf7, 0x90,
	0x17, 0x06, 0x24, 0x62, 0x92, 0x2c, 0x87, 0x35, 0x48, 0x48, 0x30, 0x3c, 0x81, 0xad, 0x4c, 0xc0,
	0xdc, 0x2c, 0x73, 0x45, 0x30, 0x6f, 0x66, 0xc8, 0x83, 0xf9, 0xbd, 0xbb, 0x60, 0xb2, 0x90, 0xba,
	0x32, 0x96, 0xbe, 0xf0, 0xaf, 0x6e, 0x03, 0x0b, 0xe9, 0x50, 0x22, 0xd6, 0xaf, 0x06, 0x34, 0x66,
	0x7b, 0x92, 0xb3, 0x47, 0xe4, 0x52, 0x87, 0x4f, 0x6d, 0x43, 0x88, 0x66, 0xef, 0x1a, 0xf4, 0x10,
	0x6a, 0x9a, 0x58, 0xca, 0x4e, 0xf1, 0x4c, 0x1e, 0x6c, 0xcd, 0x51, 0x28, 0xd3, 0x72, 0x71, 0x71,
	0xe4, 0x6a, 0xa3, 0x52, 0xa8, 0x8d, 0x0f, 0x7f, 0x80, 0xaa, 0xe8, 0x38, 0xb4, 0x06, 0xab, 0x87,
	0x2f, 0xf6, 0x9c, 0xa1, 0x7b, 0x3c, 0xfe, 0x6a, 0x7c, 0xf0, 0xcd, 0xb8, 0xfd, 0xbf, 0x39, 0x74,
	0x68, 0x0f, 0x0f, 0xf7, 0xec, 0x61, 0xdb, 0x40, 0xdb, 0xb0, 0x29, 0xa1, 0xd1, 0x78, 0x74, 0x34,
	0xda, 0x7b, 0xe5, 0x0e, 0x5e, 0x1d, 0x3b, 0x47, 0x43, 0xbb, 0x5d, 0x42, 0x5b, 0xb0, 0x2e, 0x49,
	0x2f, 0x0f, 0x46, 0x63, 0x77, 0xf8, 0xed, 0xc8, 0x39, 0x1a, 0x8d, 0x9f, 0xb7, 0xcb, 0xa8, 0x03,
	0x1b, 0x92, 0x30, 0xd8, 0x1b, 0x0f, 0x86, 0xaf, 0x66, 0xd2, 0x2a, 0xbb, 0xbf, 0x54, 0x00, 0x71,
	0xd7, 0xf6, 0x71, 0x84, 0xcf, 0x48, 0xea, 0x90, 0xf4, 0x4d, 0xe0, 0x11, 0xf4, 0x04, 0x6a, 0xea,
	0x35, 0x86, 0x36, 0xa4, 0xff, 0x8b, 0xef, 0xb5, 0xee, 0x66, 0x0e, 0x55, 0x03, 0xfa, 0x09, 0xd4,
	0x9c, 0xc5, 0x7b, 0xce, 0xd2, 0x7b, 0xf9, 0x07, 0xca, 0x18, 0x5a, 0xb9, 0x5d, 0x8d, 0x6e, 0x4b,
	0xce, 0xe5, 0xaf, 0x93, 0xee, 0x9d, 0x7f, 0xa0, 0x2a, 0x79, 0x4f, 0xc1, 0xcc, 0x0c, 0x07, 0xd4,
	0x91, 0xdc, 0xc5, 0xa1, 0xd9, 0xdd, 0x5e, 0x42, 0x99, 0xcb, 0xc8, 0x34, 0xa5, 0x96, 0x51, 0x9c,
	0x2d, 0x5a, 0xc6, 0x92, 0x0e, 0x46, 0x9f, 0x41, 0x5d, 0x2f, 0x31, 0xa4, 0x5c, 0xcf, 0x2d, 0xe3,
	0xee, 0xcd, 0x3c, 0xac, 0xae, 0x7e, 0x01, 0x8d, 0xd9, 0x52, 0x41, 0x33, 0xa6, 0xc5, 0x3d, 0xd7,
	0xdd, 0x2a, 0xe0, 0x73, 0xc5, 0x7a, 0x6f, 0x68, 0xc5, 0xb9, 0x6d, 0xa4, 0x15, 0xe7, 0xd7, 0xcb,
	0xd3, 0xfb, 0xdf, 0x59, 0x17, 0x71, 0x42, 0xfa, 0x41, 0x2c, 0xfe, 0x33, 0x3d, 0x9a, 0xc8, 0xd2,
	0x78, 0xbc, 0xf0, 0x77, 0xea, 0x64, 0x45, 0xfc, 0x8f, 0xfa, 0xe4, 0xef, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x56, 0x73, 0x31, 0x21, 0x66, 0x0d, 0x00, 0x00,
}
